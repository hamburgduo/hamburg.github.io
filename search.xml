<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[celery 实现远程任务执行]]></title>
    <url>%2F2019%2F07%2F20%2Fcelery%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[角色分配 10.111.24.74 | broker | worker 10.111.24.75 producer 发送任务给74的worker执行 安装准备两台机器都安装的Python包12pip install celerypip install redis 74安装broker，本例采用redis12345678910111213yum -y instal redis# 配置可远程连接，配置密码vi /etc/redis.conf# 密码设置requirepass 1234567890Aa# 允许远程访问设置# 注释掉 bind 127.0.0.1 并关闭保护模式# bind 127.0.0.1protected-mode no# 启动service start redis 项目结构10.111.24.7412345678# celery_app.├── celeryconfig.py├── celeryconfig.pyc├── __init__.py├── __init__.pyc├── test_task.py└── test_task.pyc __init__.py12345678# -*- coding: utf-8 -*-from celery import Celery# 创建 Celery 实例app = Celery('celery_app') # 通过 Celery 实例加载配置模块app.config_from_object('celery_app.celeryconfig') celeryconfig.py123456789101112# -*- coding: utf-8 -*-# 指定 BrokerBROKER_URL = 'redis://:1234567890Aa@10.111.24.74:6379/0' # 指定 BackendCELERY_RESULT_BACKEND = 'redis://:1234567890Aa@10.111.24.74:6379/1' # 指定时区，默认是 UTCCELERY_TIMEZONE='Asia/Shanghai' # 指定导入的任务模块CELERY_IMPORTS = ( 'celery_app.test_task') test_task.py1234567891011# -*- coding: utf-8 -*-import timefrom celery_app import app@app.taskdef multiply(x, y): time.sleep(4) return x * y 10.111.24.75 项目结构 将74主机上的celery_app整个目录拷到75主机任一目录12345678├── celery_app│ ├── celeryconfig.py│ ├── celeryconfig.pyc│ ├── __init__.py│ ├── __init__.pyc│ ├── test_task.py│ └── test_task.pyc└── producer.py producer.py 与celery_app同级目录新建producer.py，用于发送任务 12345678910# -*- coding: utf-8 -*-from celery_app import appfrom celery_app.test_task import multiplyprint("send task to 74....")multiply.delay(56, 89)print("end....")# send_task方法，发送任务app.send_task("celery_app.test_task.multiply",args=(32,3)) 在74主机上，启动celery worker1/usr/bin/python /usr/bin/celery -A celery_app worker -l INFO 启动后的woker如图 75主机上发送任务12# 75上执行，发送耗时任务给74的workerpython producer.py 如图：左边74窗口worker接收来自75的任务 参考：分布式异步任务队列神器-Celery 参考：一文搞懂 Celery 远程任务调度]]></content>
      <tags>
        <tag>celery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 jvisualvm监控ambari-server内存情况]]></title>
    <url>%2F2019%2F06%2F05%2F%E4%BD%BF%E7%94%A8%20jvisualvm%E7%9B%91%E6%8E%A7ambari-server%E5%86%85%E5%AD%98%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[1. jvisualvm 启动123456# 启动windows 命令行cmd # 输入jvisualvm# 或者$JAVA_HOME/bin/jvisualvm 2. ambari-server 配置文件中添加JVM remoted jmx相关参数 port 选用一个未占用的端口 1234567# 在ambari-env.sh中添加 remote jmx参数vi /var/lib/ambari-server/ambari-env.sh# 要添加的参数如下-Dcom.sun.management.jmxremote=true -Dcom.sun.management.jmxremote.port=4444 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false# 添加后的export AMBARI_JVM_ARGS=$AMBARI_JVM_ARGS' -Xms512m -Xmx2048m -XX:MaxPermSize=128m -Djava.security.auth.login.config=$ROOT/etc/ambari-server/conf/krb5JAASLogin.conf -Djava.security.krb5.conf=/etc/krb5.conf -Djavax.security.auth.useSubjectCredsOnly=false -Dcom.sun.management.jmxremote=true -Dcom.sun.management.jmxremote.port=4444 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false' 修改完后，重启ambari-server 3. ViualVM中添加远程主机 4. 添加JMX连接 端口与参数配置里保持一致即可 5. 查看监控信息，堆内存使用情况，进程数量等 参考：How to monitor AmbariServer’s memory using jvisualvm or jconsole ? 配置jmxremote 参数后，可通过ambari中的grafana监控 Ambari Server JVM 在未配置jmx remote参数时，通过grafana dashboard无法监控到数据 登录地址： grafana_host:3000 参考：Apache Ambari Operations]]></content>
      <tags>
        <tag>Ambari</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVM是逻辑盘卷管理]]></title>
    <url>%2F2018%2F10%2F26%2FLVM%E6%98%AF%E9%80%BB%E8%BE%91%E7%9B%98%E5%8D%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 概念LVM是逻辑盘卷管理（Logical Volume Manager）的简称,可以在服务器不停机前提下，自如对文件系统的大小进行调整。LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。 PV(physical volume)：物理卷在逻辑卷管理系统最底层，可为整个物理硬盘或实际物理硬盘上的分区。 VG(volume group)：卷组建立在物理卷上，一卷组中至少要包括一物理卷，卷组建立后可动态的添加卷到卷组中，一个逻辑卷管理系统工程中可有多个卷组。 LV(logical volume)：逻辑卷建立在卷组基础上，卷组中未分配空间可用于建立新的逻辑卷，逻辑卷建立后可以动态扩展和缩小空间。 PE(physical extent)：物理区域是物理卷中可用于分配的最小存储单元，物理区域大小在建立卷组时指定，一旦确定不能更改，同一卷组所有物理卷的物理区域大小需一致，新的pv加入到vg后，pe的大小自动更改为vg中定义的pe大小。 LE(logical extent)：逻辑区域是逻辑卷中可用于分配的最小存储单元，逻辑区域的大小取决于逻辑卷所在卷组中的物理区域的大小。当系统添加了新的磁盘，通过LVM管理员就==不必将磁盘的文件移动到新的磁盘上以充分利用新的存储空间，而是直接扩展文件系统跨越磁盘。== 2. 常用命令 查看显示 所有信息 创建 扩容 删除 激活 扫描查找 LV lvdispaly lvs lvcreate lvextend lvremove lvchange lvscan VG vgdisplay vgs vgcreate vgremove vgchange vgscan PV pvdisplay pvs pvcreate pvextend pvremove pvchange pvscan 参考资料：lvm卷管理LVM中的PV、VG、LV、PE、LE的关系 3. 实践应用/root, /var, /usr, /tmp, /swap四个lv都属于centos这个vg12345678910111213141516171819[root@13-92 ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert root centos -wi-ao---- 47.80g swap centos -wi-ao---- 2.00g tmp centos -wi-ao---- 6.00g usr centos -wi-ao---- 22.00g var centos -wi-ao---- 22.00g lv_0 vg_0 -wi-ao---- 200.00g lv_1 vg_1 -wi-ao---- 200.00g [root@13-92 ~]# vgs VG #PV #LV #SN Attr VSize VFree centos 1 5 0 wz--n- 99.80g 4.00m vg_0 1 1 0 wz--n- 200.00g 0 vg_1 1 1 0 wz--n- 200.00g 0 [root@13-92 ~]# pvs PV VG Fmt Attr PSize PFree /dev/sda2 centos lvm2 a-- 99.80g 4.00m # centos这个vg只有 100G /dev/sdb vg_0 lvm2 a-- 200.00g 0 /dev/sdc vg_1 lvm2 a-- 200.00g 0 4. 实践应用–扩展某一数据目录扩展前, /var 100%使用空间已满123456789101112131415[root@13-92 ~]# df -ThFilesystem Type Size Used Avail Use% Mounted on/dev/mapper/centos-root xfs 48G 2.0G 46G 5% /devtmpfs devtmpfs 16G 0 16G 0% /devtmpfs tmpfs 16G 44K 16G 1% /dev/shmtmpfs tmpfs 16G 1.6G 15G 10% /runtmpfs tmpfs 16G 0 16G 0% /sys/fs/cgroup/dev/mapper/centos-usr xfs 22G 8.6G 14G 39% /usr/dev/mapper/vg_0-lv_0 xfs 200G 147M 200G 1% /indata/disk_0/dev/mapper/vg_1-lv_1 xfs 200G 5.5G 195G 3% /indata/disk_1/dev/mapper/centos-var xfs 22G 22G 20K 100% /var ## /var 100% used/dev/mapper/centos-tmp xfs 6.0G 353M 5.7G 6% /tmp/dev/sda1 xfs 197M 92M 105M 47% /boottmpfs tmpfs 3.2G 0 3.2G 0% /run/user/1000tmpfs tmpfs 3.2G 0 3.2G 0% /run/user/0 1. 新建分区1234567891011121314151617fdisk /dev/sdan --创建新分区&lt;回车&gt; --默认主分区&lt;回车&gt; --默认分区编号&lt;回车&gt; --默认起始扇区位置。&lt;回车&gt; --默认结束扇区位置。w# 输出信息The partition table has been altered!Calling ioctl() to re-read partition table.WARNING: Re-reading the partition table failed with error 16: Device or resource busy.The kernel still uses the old table. The new table will be used atthe next reboot or after you run partprobe(8) or kpartx(8)Syncing disks. 2. 使用工具partprobe让kernel读取分区信息123partprobe# 使用fdisk工具只是将分区信息写到磁盘，如果需要mkfs磁盘分区则需要重启系统，# 而使用partprobe则可以使kernel重新读取分区信息，从而避免重启系统。 3. 查看多出的新分区1234567891011121314151617181920212223fdisk -l# 输出Disk /dev/sdb: 214.7 GB, 214748364800 bytes, 419430400 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/sdc: 214.7 GB, 214748364800 bytes, 419430400 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/sda: 644.2 GB, 644245094400 bytes, 1258291200 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x0005b7b2 Device Boot Start End Blocks Id System/dev/sda1 * 2048 411647 204800 83 Linux/dev/sda2 411648 209715199 104651776 8e Linux LVM/dev/sda3 209715200 1258291199 524288000 83 Linux 4. 创建物理分区pvcreate123pvcreate /dev/sda3# 输出Physical volume "/dev/sda3" successfully created 5. 扩展卷组vgextend [ lvs查看可知，/var属于centos卷组]123vgextend centos /dev/sda3# 输出Volume group "centos" successfully extended 6. 扩展逻辑分区lvextend [扩展/var]12345# 扩展50Glvextend -L +50G /dev/mapper/centos-var# 输出Size of logical volume centos/var changed from 22.00 GiB (5632 extents) to 72.00 GiB (18432 extents). Logical volume var successfully resized. 7. 扩展文件系统xfs_growfs123456789101112xfs_growfs /dev/mapper/centos-var# 输出meta-data=/dev/mapper/centos-var isize=256 agcount=4, agsize=1441792 blks = sectsz=512 attr=2, projid32bit=1 = crc=0 finobt=0data = bsize=4096 blocks=5767168, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=0log =internal bsize=4096 blocks=2816, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0data blocks changed from 5767168 to 18874368 说明：因为安装CentOS用的xfs分区，所以使用命令xfs_growfs扩展文件系统大小。否则的话使用resize2fs命令。 扩展后, /var 31% Used12345678910111213141516df -Th # 输出Filesystem Type Size Used Avail Use% Mounted on/dev/mapper/centos-root xfs 48G 2.0G 46G 5% /devtmpfs devtmpfs 16G 0 16G 0% /devtmpfs tmpfs 16G 44K 16G 1% /dev/shmtmpfs tmpfs 16G 1.6G 15G 10% /runtmpfs tmpfs 16G 0 16G 0% /sys/fs/cgroup/dev/mapper/centos-usr xfs 22G 8.6G 14G 39% /usr/dev/mapper/vg_0-lv_0 xfs 200G 147M 200G 1% /indata/disk_0/dev/mapper/vg_1-lv_1 xfs 200G 5.4G 195G 3% /indata/disk_1/dev/mapper/centos-var xfs 72G 22G 50G 31% /var # %31 used/dev/mapper/centos-tmp xfs 6.0G 353M 5.7G 6% /tmp/dev/sda1 xfs 197M 92M 105M 47% /boottmpfs tmpfs 3.2G 0 3.2G 0% /run/user/1000tmpfs tmpfs 3.2G 0 3.2G 0% /run/user/0 参考：CentOS 7扩展根分区]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pip 常用命令及技巧]]></title>
    <url>%2F2018%2F10%2F18%2Fpip%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[基本命令12345678910# 查看版本、帮助pip --versionpip --help# 查看已安装的python包pip list# pip安装、卸载pip install pkg_namepip install Django==1.7pip uninstall pkg_namepip uninstall -y pkg_name pip加速源或者是全局配置12345678910111213pip install -i https://pypi.douban.com/simple/ pkg_name# 创建全局配置文件cd ~mkdir .pipcd .pipvi pip.config# 配置文件找那个添加如下代码[global]timeout = 60index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com 离线安装1234# 下载包及其依赖pip download -d /root/pipfiles pkg_name# 离线安装pip install pkg_name --no-index --find-links=/root/pipfiles/ 一篇很透彻的python包，离线安装指南 pip 官方用户指导参考]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 设定网络参数]]></title>
    <url>%2F2018%2F10%2F18%2FCentos%20%E8%AE%BE%E5%AE%9A%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[12# 编辑ifcfg-eth0配置文件vi /etc/sysconfig/network-scripts/ifcfg-eth0 1234567891011121314151617TYPE="Ethernet"BOOTPROTO="none" # 取得IP的方式，dhcp动态获取，手动可输入none或static静态DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"NAME="eth0"DEVICE="eth0" # 网卡名称ONBOOT="yes" # 系统启动时是否激活网卡，只有在激活状态(yes)的网卡才能去连接网络，进行网络通讯PREFIX=24IPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPADDR=10.110.13.33 # 静态IPGATEWAY=10.110.13.254 # 网关 12345# 重启网络service network restart# 检查ip ifconfg ip a 参考资料：鸟哥，设置固定ip地址]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[httpd 配置负载均衡（负载均衡多个服务）]]></title>
    <url>%2F2018%2F10%2F16%2Fhttpd%20%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[监听多个端口，负载均衡多个服务httpd.conf12345678910# 修改httpd.confvi /etc/httpd/conf/httpd.conf# 监听多个端口Listen 80Listen 6080Listen 8443# 服务的virtual host配置文件Include conf/ranger-cluster.confInclude conf/knox-cluster.conf 新建 ranger-cluster.conf 与 knox-cluster.conf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768cd /etc/httpd/confvi ranger-cluster.conf# ranger服务配置文件详情## This is the Apache server configuration file providing SSL support.# It contains the configuration directives to instruct the server how to# serve pages over an https connection. For detailing information about these# directives see &lt;URL:http://httpd.apache.org/docs/2.2/mod/mod_ssl.html&gt;## Do NOT simply read the instructions in here without understanding# what they do. They're here only as hints or reminders. If you are unsure# consult the online docs. You have been warned.#Listen 80&lt;VirtualHost *:6080&gt; ProxyRequests off ProxyPreserveHost on Header add Set-Cookie "ROUTEID=.%&#123;BALANCER_WORKER_ROUTE&#125;e; path=/" env=BALANCER_ROUTE_CHANGED &lt;Proxy balancer://rangercluster&gt; BalancerMember http://10.110.13.91:6080 loadfactor=1 route=1 BalancerMember http://10.110.13.92:6080 loadfactor=1 route=2 Order Deny,Allow Deny from none Allow from all ProxySet lbmethod=byrequests scolonpathdelim=On stickysession=ROUTEID maxattempts=1 failonstatus=500,501,502,503 nofailover=Off &lt;/Proxy&gt; # balancer-manager # This tool is built into the mod_proxy_balancer # module and will allow you to do some simple # modifications to the balanced group via a gui # web interface. &lt;Location /balancer-manager&gt; SetHandler balancer-manager Order deny,allow Allow from all &lt;/Location&gt; ProxyPass /balancer-manager ! ProxyPass / balancer://rangercluster/ ProxyPassReverse / balancer://rangercluster/&lt;/VirtualHost&gt;vi ranger-cluster.conf# konx服务配置文件详情&lt;VirtualHost *:8443&gt; ProxyRequests off ProxyPreserveHost on Header add Set-Cookie "ROUTEID=.%&#123;BALANCER_WORKER_ROUTE&#125;e; path=/" env=BALANCER_ROUTE_CHANGED &lt;Proxy balancer://knoxcluster&gt; BalancerMember http://10.110.13.91:8444 loadfactor=1 route=1 BalancerMember http://10.110.13.92:8444 loadfactor=1 route=2 Order Deny,Allow Deny from none Allow from all ProxySet lbmethod=byrequests scolonpathdelim=On stickysession=ROUTEID maxattempts=1 failonstatus=500,501,502,503 nofailover=Off &lt;/Proxy&gt; # balancer-manager # This tool is built into the mod_proxy_balancer # module and will allow you to do some simple # modifications to the balanced group via a gui # web interface. &lt;Location /balancer-manager&gt; SetHandler balancer-manager Order deny,allow Allow from all &lt;/Location&gt; ProxyPass /balancer-manager ! ProxyPass / balancer://knoxcluster/ ProxyPassReverse / balancer://knoxcluster/&lt;/VirtualHost&gt; ranger 服务的balancer-manager界面6080 knox 服务balancer-manager界面8443 负载均衡开启的模块，模块含义表： httpd.conf配置文件中加载的模块 模块名称 模块功能 LoadModule proxy_module modules/mod_proxy.so proxy_module 提供代理服务器功能 LoadModule proxy_balancer_module modules/mod_proxy_balancer.so proxy_balancer_module 提供负载均衡功能 LoadModule proxy_http_module modules/mod_proxy_http.so proxy_http_module 代理服务器能支持HTTP协议 LoadModule proxy_ajp_module modules/mod_proxy_ajp.so proxy_ajp_module 代理服务器能支持AJP协议 LoadModule slotmem_shm_module modules/mod_slotmem_shm.so slotmem_shm_module 基于插槽的共享内存提供程序 LoadModule lbmethod_byrequests_module modules/mod_lbmethod_byrequests.so lbmethod_byrequests_module 负载均衡算法：按照请求次数均衡(默认) LoadModule lbmethod_bytraffic_module modules/mod_lbmethod_bytraffic.so lbmethod_bytraffic_module 负载均衡算法：按照流量均衡 LoadModule lbmethod_bybusyness_module modules/mod_lbmethod_bybusyness.so lbmethod_bybusyness_module 负载均衡算法：按照繁忙程度均衡(总是分配给活跃请求数最少的服务器) 更多模块详情：官网信息参考资料：Apache 2.4 配置说明]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git多账号配置问题]]></title>
    <url>%2F2018%2F10%2F15%2Fgit%20commit%20%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述：github 仓库commit之后，contributions不显示，如图： 问题原因查找官方描述：You haven’t added your local Git commit email to your profile Commits must be made with an email address that has been added to your GitHub profile in order to appear on your contributions graph. You can check the email address used for a commit by adding .patch to the end of a commit URL, e.g. https://github.com/octocat/octocat.github.io/commit/67c0afc1da354d8571f51b6f0af8f2794117fd10.patch:1234From 67c0afc1da354d8571f51b6f0af8f2794117fd10 Mon Sep 17 00:00:00 2001From: The Octocat &lt;octocat@nowhere.com&gt;Date: Sun, 27 Apr 2014 15:36:39 +0530Subject: [PATCH] updated index for better welcome message 即提交用户邮箱与github注册的邮箱不对应，导致contributions图不能正常显示。 不匹配的用户名与邮箱 匹配的用户名与邮箱【contributions图正常显示】 不匹配的原因分析由于在C盘用户目录下.gitconfig文件下配置：公司的TFS代码仓库的账户和邮箱，该配置为全局配置，导致github代码仓库也用该配置，所以不显示contributions。123[user]name = xxxemail = xxx@xxx.com 多账号配置 每个仓库单独配置[user],不使用全局配置 （避免账号邮箱串用） 公司的仓库配置公司的用户名及邮箱 私人的github仓库配置github账号及注册邮箱.git目录下的config文件中添加,[user]部分的配置： 123[user]name = xxxemail = xxx@xxx.com 也可以利用命令操作1git config user.email "email@example.com" 参考：Setting your email address for a single repository]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网关(Gateway)]]></title>
    <url>%2F2018%2F10%2F11%2F%E7%BD%91%E5%85%B3(Gateway)%2F</url>
    <content type="text"><![CDATA[定义 网关是OSI参考模型中负责将从传输层到应用层的数据进行转换和转发的设备。 网间连接器、协议转换器。 网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。 网关不仅转发数据还负责对数据进行转换，它通常会使用一个表示层或应用层网关，在两个不能进行直接通信的协议之间进行翻译，最终实现两者之间的通信。 实例互联网邮件与手机邮件之间的转换服务。手机邮件有时可能会与互联网邮件互不兼容，这是由于它们在表示层和应用层中的“电子邮件协议”互不相同所致。 如图，邮件网关。网关负责读取完各种不同协议后，对它们逐一进行合理转换，再将相应的数据转发出去。这样一来即使应用的是不同电子邮件协议，计算机与手机之间也能互相发送邮件。 控制网络流量和用于安全的代理服务器也是一种应用网关。有了代理服务器，客户端与服务器之间无需在网络层上直接通信，而是从传输层到应用层对数据和访问进行各种控制和处理。 防火墙就是一款通过网关通信，针对不同应用提高安全性的产品。 参考资料： 图解TCP/IP]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Promise使用小记--vue-resouce多次请求的顺序执行]]></title>
    <url>%2F2018%2F09%2F14%2FPromise%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0--vue-resouce%E5%A4%9A%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[问题描述：页面加载时： 请求主机组列表； 根据上一步请求的结果，再次请求group_list[0]下的可用主机的前三台； 未使用promise之前的代码：12345678910111213// 第一次请求this.getHostGroupList();// 默认选择第一个主机组// 等待200m后，发起第二次请求 setTimeout(() =&gt; &#123; this.newPlatformInfo.group_name = this.group_list[0]; this.selectGroup(this.group_list[0]); &#125;, 200);// 默认选用前三台主机搭建foundation环境// 再等待200ms(400 - 200),对第二次请求的结果进行切分处理 setTimeout(() =&gt; &#123; this.newPlatformInfo.selected_hosts = this.availableHosts.slice(0, 3); &#125;, 400); 延时的处理的弊端： 设置的延时时间，是开发过程中的测试时间； 实际应用过程中会因为请求响应的时间长短，很容易出现赋值失败的情况； 使用promise实现请求的链式调用：.then().then()123456789let that = this;this.getHostGroupList() // vue的this .then((group_list) =&gt; &#123; that.newPlatformInfo.group_name = that.group_list[0]; // promise内部that替代this return that.selectGroup(group_list[0]); // then()方法中返回Promise对象 &#125;) .then((available_host) =&gt; &#123; that.newPlatformInfo.selected_hosts = available_host.slice(0, 3); &#125;); 对getHostGrouplist(),selectGroup()两个方法的promise改造：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*1. 将请求的代码块封在Promise内部,并return new Promise()2. 通过resolve将结果数据传回去3. promise里的this和vue中的this指向不同，Promise内部用that变量*/getHostGroupList() &#123; let that = this; return new Promise(function (resolve) &#123; that.$http.post(that.api('get_available_hosts'), &#123;platform_name: 'indata_foundation', group_name: ''&#125;) .then(response =&gt; &#123; let res = JSON.parse(response.bodyText); let group_list = []; let host_list = res.platform_available_hosts.indata_foundation; for (let index in host_list) &#123; group_list.push(host_list[index].group_name); &#125; that.group_list = group_list; resolve(group_list); &#125;); &#125;) &#125;, selectGroup(group) &#123; let that = this; return new Promise((resolve) =&gt; &#123; // 清空已选主机的tag that.newPlatformInfo.selected_hosts = []; let post_data = &#123; platform_name: 'indata_foundation', // 基础环境下，可用主机列表 group_name: group &#125;; let available_host = []; that.$http.post(that.api('get_available_hosts'), post_data) .then(response =&gt; &#123; let res = JSON.parse(response.bodyText); // 当前组内的主机列表 let indata_foundation_list = res.platform_available_hosts.indata_foundation; for (let index in indata_foundation_list) &#123; if (indata_foundation_list[index].group_name == post_data.group_name) &#123; available_host = indata_foundation_list[index].host_ips &#125; &#125; that.availableHosts = available_host; resolve(available_host); &#125;); &#125;); &#125;, 参考1：vue中promise和axios 同步爬坑小记参考2：vue中promise的使用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本--常用的小命令记录]]></title>
    <url>%2F2018%2F08%2F30%2Fshell%E8%84%9A%E6%9C%AC--%E5%B8%B8%E7%94%A8%E5%B0%8F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[read 从键盘读取变量值read [option] variable 选项-p： 加提示字符(prompt)-t： 输入值等待的时间(s)12345# 注意参数、变量之间的空格[root@33 ~]# read -p 'Enter your name:' -t 10 first_name last_nameEnter your name:Tom Li[root@33 ~]# echo $first_name $last_nameTom Li echo 取用变量或者输出指定字符串echo [option] var 选项-e：激活转义字符123456789[root@33 ~]# echo -e '\n\n\t' [root@33 ~]# echo '\n\n\t'\n\n\t# 输出变量需要变量名前加美元符号$[root@33 ~]# echo $JAVA_HOME/usr/local/jdk echo加管道命令|自动回复yes 或者直接yes12345678910[root@33 ~]# lstest.txt test.txt.bak# 存在test.txt.bak，执行cp会提示是否覆盖[root@33 ~]# cp test.txt test.txt.bakcp: overwrite ‘test.txt.bak’? # 此处等待用户输入yes/no# echo yes 或者 yes 自动回复[root@33 ~]# echo yes | cp test.txt test.txt.bak cp: overwrite ‘test.txt.bak’? [root@33 ~]# [root@33 ~]# yes | cp test.txt test.txt.bak cp: overwrite ‘test.txt.bak’? [root@33 ~]# 一条命令中的子命令——`` 或 $() 在一串命令中，还需要藉由其他的命令提供的信息，可以使用反单引号『命令』或 『$(命令)』。123456[root@33 ~]# version=`cat /etc/redhat-release`[root@33 ~]# echo $version CentOS Linux release 7.2.1511 (Core)[root@33 ~]# currpath=$(pwd)[root@33 ~]# echo $currpath/root]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router全局守卫使用记录]]></title>
    <url>%2F2018%2F08%2F30%2Fvue-router%E5%85%A8%E5%B1%80%E5%AE%88%E5%8D%AB%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[router.beforeEach 全局前置守卫的注册 独立的permission.js文件 在main.js中import ‘path/permission.js’,实现全局前置守卫12345678910111213141516171819202122232425262728import Vue from &apos;vue&apos;import router from &quot;../router&quot;;let self = Vue.prototype;router.beforeEach((to, from, next) =&gt; &#123; if (to.path === &quot;/login&quot;) &#123; self.DR.isLogin = true; next() &#125; else if (self.cookie.get(&apos;username&apos;)) &#123; Vue.http.post(self.api(&apos;login&apos;)).then( (response) =&gt; &#123; const res = JSON.parse(response.bodyText); if (res.state === 0) &#123; next() &#125; else &#123; self.DR.isLogin = true; next(&apos;/login&apos;); // 强制再刷新一次，目的是隐藏头部导航菜单 window.location.reload(); &#125; &#125;, (response) =&gt; &#123; &#125; ); &#125; else &#123; next(&apos;/login&apos;) &#125;&#125;); 关于next()方法 官方定义：一定要调用该方法来 resolve 这个钩子。 确保要调用 next 方法，否则钩子就不会被 resolved。 个人理解： beforeEach方法体内的每一个条件(if/else)，都要有next()方法出口。 官方：导航守卫vue2.0 实现导航守卫（路由守卫）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(*args)与(**kwargs)魔法变量]]></title>
    <url>%2F2018%2F08%2F29%2Fpython%E9%AD%94%E6%B3%95%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[当函数中参数的数量可变时，通常使用魔法变量；args 与 \*kwargs 只是习惯写法，你完全可以用 params 与 \*params或者其他任意参数名；当声明一个 args 参数时，此处开始所有的 位置参数 被收集成一个名为 args的元组（tuple）中；当声明一个 \*kwargs 参数时， 此处开始所有的 关键字参数 被收集为名为 kwargs的字典（dict）中。 使用顺序：1234# 1.命名参数 2.非关键字可变长参数列表 3.关键字可变长参数；# 关键字可变长参数排最后def some_func(fargs, *args, **kwargs): pass 函数定义时，代码示例：1234567891011def total(a=5, *numbers, **phonebook): print('a', a) #遍历元组中的所有项目 for single_item in numbers: print('single_item', single_item) #遍历字典中的所有项目 for first_part, second_part in phonebook.items(): print(first_part,second_part) res = total(10,1,2,3,Jack=1123,John=2231,Inge=1560)print(res) 运行结果:12345678('a', 10)('single_item', 1)('single_item', 2)('single_item', 3)('Inge', 1560)('John', 2231)('Jack', 1123)None 函数调用时，代码示例：123456def print_three_things(a, b, c): print 'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'.format(a,b,c) a = ['Tom', 'Jack', 'Lucy']print_three_things(*a) 运行结果：1a = Tom, b = Jack, c = Lucy 12345678910def format_output(): tom = &#123; "gender":"male", "age":21 &#125; print('gender:&#123;gender&#125;,age:&#123;age&#125;'.format(**tom)) print('gender: &#123;gender&#125;'.format(**tom)) print('age: &#123;age&#125;'.format(**tom)) format_output() 运行结果：123gender:male,age:21gender: maleage: 21 参考： args and *kwargs]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据流重定向使用记录]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[数据流向与命令的关系 三种文件描述符 文件 文件描述符 覆盖操作符 追加加操作符 标准输入 STDIN 0 &lt; &lt;&lt; 标准输出 STDOUT 1 1&gt; 1&gt;&gt; 标准错误输出 STDERR 2 2&gt; 2&gt;&gt; 说明：标准输出的操作符，文件描述符可省略即[覆盖&gt;,追加&gt;&gt;] 示例：输出重定向1234567891011121314151617[root@iop ~]# su test // 由root用户，切换至test用户[test@iop ~]$ find /home/ -name .bashrc // 在test用户的家目录查找 .bashrc文件名find: ‘/home/admin’: Permission denied // 标准错误输出find: ‘/home/deploymgr’: Permission denied // 标准错误输出/home/test/.bashrc // 标准输出// 将标准输出重定向至list_right;将标准错误重定向至list_error[test@iop ~]$ find /home -name .bashrc &gt; list_right 2&gt; list_error[test@iop ~]$ lslist_error list_right[test@iop ~]$ cat list_error find: ‘/home/admin’: Permission deniedfind: ‘/home/deploymgr’: Permission denied[test@iop ~]$ cat list_right /home/test/.bashrc 示例：标准输出与标准错误重定向至同一个文件(&gt;&amp;)123456789101112131415[test@iop ~]$ ls list_right rightls: cannot access right: No such file or directory // 标准错误输出list_right // 标准输出// 先将标准输出重定向至onefile,再将标准错误重定向至onefile[test@iop ~]$ ls list_right right &gt; onefile 2&gt;&amp;1[test@iop ~]$ cat onefile ls: cannot access right: No such file or directorylist_right// 先将标准错误重定向至anotherfile,再将标准输出重定向至anotherfile[test@iop ~]$ ls list_right right 2&gt; anotherfile &gt;&amp;2[test@iop ~]$ cat anotherfile ls: cannot access right: No such file or directorylist_right 示例： 输入重定向1234567891011[test@iop ~]$ cat &gt; catfile &lt;&lt; 'EOF' // &gt; 自动创建catfile这个文件，&gt; test &gt; test&gt; test test cat &gt; EOF // &lt;&lt; 键盘输入至字符'EOF'，停止接收字符[test@iop ~]$ cat &gt; catfile2 &lt; catfile // 将文件catfile作为重定向的标准输入，并重定向输出至catfile2这文件[test@iop ~]$ cat catfile2testtesttest test cat 鸟哥linux私房菜：数据流重导向Input Output Redirection in Linux/Unix ExamplesAn Introduction to Linux I/O Redirection]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sed 流编辑器的使用（stream editor）]]></title>
    <url>%2F2018%2F08%2F18%2Fsed%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%20%2F</url>
    <content type="text"><![CDATA[基本介绍流编辑器用于对输入流（文件或来自管道的输入）执行基本文本转换。处理时以行为单位，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。 命令格式12345// 常用命令格式# sed SCRIPT INPUTFILE...// 全格式命令# sed OPTIONS... [SCRIPT] [INPUTFILE...] OPTIONS 选项参数1234567-e &lt;script&gt;或--expression=&lt;script&gt;：以选项中的指定的script来处理输入的文本文件；-n 或--quiet或——silent：仅显示script处理后的结果；-i 直接修改inputfile,而不是将处理结果输出到屏幕；-f &lt;script文件&gt;或--file=&lt;script文件&gt;：以选项中指定的script文件来处理输入的文本文件；-h 或--help：显示帮助；--version：显示版本信息。 SCRIPT常用命令(也称commond，由行号或者pattern + 命令组成，由‘’包裹)1234567a 在当前行下面插入文本。i 在当前行上面插入文本。c 把选定的行改为新的文本。d 删除，删除选择的行。s 替换指定字符。g 表示行内全局替换。p 打印模板块的行。 实战举例：s命令123456sed -i 's/my/him' test.txt// -i 参数直接修改文件内容// s 表示替换命令// g 替换每一行中的所有匹配sed 's/my/him/g' test.txt &gt; him_test.txt// 将替换后的结果，重定向到 him_test.txt文件 实战举例：a命令123456789101112131415161718cat test_sed.txt # This is the test file.PORT="8088888080"# 在test_sed文件中PORT=后追加一行8081(/PORT为匹配，/a为追加一行)sed -i '/PORT=/a8081' test_sed.txt# 追加后cat test_sed.txt # This is the test file.PORT="80818088888080" 实战举例：-n参数，p命令123456789101112131415161718192021222324252627282930313233343536// nl 命令查看test_sed.txt并用管道sed 'p' 打印，每行输出两遍 # nl test_sed.txt | sed 'p' 1 # This is the test file. 1 # This is the test file. 2 PORT=" 2 PORT=" 3 8081 3 8081 4 80 4 80 5 8888 5 8888 6 8080 6 8080 7 " 7 " // nl 命令查看test_sed.txt， -n参数静默输出，只输出一遍 nl test_sed.txt | sed -n 'p' 1 # This is the test file. 2 PORT=" 3 8081 4 80 5 8888 6 8080 7 " // 输出1-3行'line1,line2p' nl test_sed.txt | sed -n '1,3p' 1 # This is the test file. 2 PORT=" 3 8081 // 输出奇数行,'line1~stepp'，起始行~步长 nl test_sed.txt | sed -n '1~2p' 1 # This is the test file. 3 8081 5 8888 7 " 更多使用细节查阅：Linux命令大全：sed命令GNU: sed page鸟哥Linux私房菜：sed 工具]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell编程--判断条件]]></title>
    <url>%2F2018%2F08%2F13%2Fshell%E7%BC%96%E7%A8%8B--%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. 关于某个档名的『文件类型』判断，如 test -e filename 表示存在否 测试的标志 代表意义 -e 该『档名』是否存在？(常用) -f 该『档名』是否存在且为文件(file)？(常用) -d 该『档名』是否存在且为目录(directory)？(常用) -b 该『档名』是否存在且为一个 block device 装置？ -c 该『档名』是否存在且为一个 character device 装置？ -S 该『档名』是否存在且为一个 Socket 文件？ -p 该『档名』是否存在且为一个 FIFO (pipe) 文件？ -L 该『档名』是否存在且为一个连结档？ 2. 关于文件的权限测试，如 test -r filename 表示可读否 (但 root 权限常有例外) 测试的标志 代表的意义 -r 侦测该档名是否存在且具有『可读』的权限？ -w 侦测该档名是否存在且具有『可写』的权限？ -x 侦测该档名是否存在且具有『可运行』的权限？ -u 侦测该档名是否存在且具有『SUID』的属性？ -g 侦测该档名是否存在且具有『SGID』的属性？ -k 侦测该档名是否存在且具有『Sticky bit』的属性？ -s 侦测该档名是否存在且为『非空白文件』？ 示例：123456789101112# stat -c %A test_do.sh -rw-r--r--# test -x test_do.sh &amp;&amp; echo "Executable" || echo "Not Executable"Not Executable# chmod +x test_do.sh# stat -c %A test_do.sh -rwxr-xr-x# test -x test_do.sh &amp;&amp; echo "Executable" || echo "Not Executable"Executable# stat -c %a test_do.sh 755 说明：对于&amp;&amp;：当前面执行条件正确时，执行&amp;&amp;之后的，错误就停住了。对于||：当前面的执行条件错误时，执行||之后的，正确就停住了。因此根据&amp;&amp;、||的特性可以对条件作出一个模式“条件 &amp;&amp; 执行1|| 执行2”。当条件为真时执行1；当为假时“条件&amp;&amp;执行1”绝对为假，因此执行2。 stat 这个命令可以实现数字形式输出文件的权限 参数 参数含义 - c –format=FORMAT %a access rights in octal （8进制数显示文件权限） %A access rights in human readable form（可阅读方式显示文件权限） 3. 关于两个整数之间的判定，例如 test n1 -eq n2 测试的标志 代表的意义 -eq 两数值相等 (equal) -ne 两数值不等 (not equal) -gt n1 大于 n2 (greater than) -lt n1 小于 n2 (less than) -ge n1 大于等于 n2 (greater than or equal) -le n1 小于等于 n2 (less than or equal) 鸟哥Linux私房菜： 第十三章、3.1 testshell编程——判断条件]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nmap使用记录]]></title>
    <url>%2F2018%2F08%2F09%2Fnmap%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Nmap（Network Mapper）是一款开放源代码的网络探测和安全审核工具。它用于快速扫描一个网络和一台主机开放的端口，还能使用TCP/IP协议栈特征探测远程主机的操作系统类型 安装1yum -y install nmap # centos redhat 主机发现123nmap -T4 -sP 10.110.13.0/24nmap -T4 -sP 10.110.13.*nmap -T4 -sn 10.110.13.0/24 以上三条命令的运行效果一样，得到相同的结果，即扫描13网段的256个ip主机的活跃状态参数说明：12345nmap --help -sn: Ping Scan - disable port scan #ping 扫描，禁用端口扫描-T&lt;0-5&gt;: Set timing template (higher is faster) # -T4 代表快速扫描* # 是通配符0/24 # 代表子网掩码(255.255.255.0) 关于子网掩码的问题请戳我 而之前一直使用-sP参数，nmap –help 与man nmap都未发现-sP参数。网上搜索一番： -sT TCP connect()扫描，这是最基本的TCP扫描方式。这种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息。 -sS TCP同步扫描(TCP SYN)，因为不必全部打开一个TCP连接，所以这项技术通常称为半开扫描(half-open)。这项技术最大的好处是，很少有系统能够把这记入系统日志。不过，你需要root权限来定制SYN数据包。 -sF,-sX,-sN 秘密FIN数据包扫描、圣诞树(Xmas Tree)、空(Null)扫描模式。这些扫描方式的理论依据是：关闭的端口需要对你的探测包回应RST包，而打开的端口必需忽略有问题的包(参考RFC 793第64页)。 -sP ping扫描，用ping方式检查网络上哪些主机正在运行。当主机阻塞ICMP echo请求包是ping扫描是无效的。nmap在任何情况下都会进行ping扫描，只有目标主机处于运行状态，才会进行后续的扫描。 -sU 如果你想知道在某台主机上提供哪些UDP(用户数据报协议,RFC768)服务，可以使用此选项。 -sA ACK扫描，这项高级的扫描方法通常可以用来穿过防火墙。 -sW 滑动窗口扫描，非常类似于ACK的扫描。 -sR RPC扫描，和其它不同的端口扫描方法结合使用。 -b FTP反弹攻击(bounce attack)，连接到防火墙后面的一台FTP服务器做代理，接着进行端口扫描。 nmap 使用参考继续查看官网发现一句英文的解释：In previous releases of Nmap, -sn was known as -sP.即旧版中为-sP官网英文doc参考 常见的使用方式12nmap 192.168.0.101-110 # ip范围nmap 192.168.0.101,102,103 # 逗号扫描多个主机 更多使用:详见]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-resource几种使用场景记录]]></title>
    <url>%2F2018%2F08%2F08%2Fvue-resource%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[post提交的数据格式为(form-data/x-www-form-urlencoded) post(url, [body], [options])options = {emulateJSON: true}以 application/x-www-form-urlencoded 内容类型发送请求报文 1234567891011121314let formData = &#123; username: 'admin', password: 'admin'&#125;;this.$http.post('/login', formData, &#123;emulateJSON: true&#125;).then( (response) =&gt; &#123; // 请求成功 &#125;, (response) =&gt; &#123; // 请求失败 &#125;) post设置请求头(headers) post(url, [body], [options])body为空占位，headers属于第三个参数[options]12345678910let token = 'Basic YWRtaW46YWRtaW4='this.$http.post('/auth',&#123;&#125;,&#123;headers: &#123;Authorization: token&#125;&#125;).then( (response) =&gt; &#123; // 请求成功 &#125;, (response) =&gt; &#123; // 请求失败 &#125;) 参考资料：How to set headers? post提交json数据(最常规) 12345678910111213let post_data = &#123; group:'test', name:'foundation'&#125;this.$http.post('/platform_hostsgroup'), post_data).then( (response) =&gt; &#123; // 请求成功 &#125;, (response) =&gt; &#123; // 请求失败 &#125;) delete方法提交json数据 使用方式：this.$http.delete(url, {body: data})12345678910let host_ip = '172.16.10.100'this.$http.delete('/host', &#123;body: &#123;ip: host_ip&#125;&#125;).then( (response) =&gt; &#123; // 请求成功 &#125;, (response) =&gt; &#123; // 请求失败 &#125;) 参考资料：vue http请求 delete传值问题]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter的安装及使用]]></title>
    <url>%2F2018%2F07%2F14%2Fjupyter%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装1pip install jupyter 生成配置文件1jupyter notebook --generate-config 设置登录密码123jupyter notebook password# 输出结果Wrote hashed password to /root/.jupyter/jupyter_notebook_config.json 后台启动服务1234nohup jupyter notebook --no-browser --allow-root --ip=0.0.0.0 &amp;# nohup command &amp; 设置后台运行# --no-browser 启动不打开浏览器# --ip 指定ip地址，可以为任意ip 使用浏览器地址栏输入server_ip:8888 访问，出现登录界面，输入设置的密码，即可使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[urllib、urllib2的使用及区别]]></title>
    <url>%2F2018%2F07%2F13%2Furllib%E3%80%81urllib2%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[urllib.urlopen()的使用12# urllib模块的urlopen()方法原型def urlopen(url, data=None, proxies=None, context=None): urlopen()打开一个给定 URL 字符串表示的 Web 连接，并返回文件类型的对象。例如,返回的对象是res，那么“句柄”会支持一些读取内容的方法，如 res.read()、res.readline()、 res.readlines()、 res.close()和 res.fileno()。其中data需要使用urllib.urlencode(dict)进行编码处理，帮我们将key:value这样的键值对转换成”key=value”这样的字符串。 123456// 实例：student = &#123;'name':'LiLei','age':18,'school': 'TsingHua'&#125;encode_student = urllib.urlencode(student)print(encode_student)age=18&amp;name=LiLei&amp;school=TsingHua // url编码后 更复杂的应用场景，使用urllib2.urlopen()12345678910# urllib2模块的urlopen()方法原型def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, cafile=None, capath=None, cadefault=False, context=None): # urllib2.Request类原型class Request: def __init__(self, url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False): 通过Request类实例化request对象，并设置请求头，认证等复杂应用123456# 实例，设置请求头等，add_header()方法def post_request(url, data): req = urllib2.Request(url + '?' + urllib.urlencode(data)) req.add_header('User-Agent','Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36') response = urllib2.urlopen(req) return response.read() 简单应用场景，三者等价12345678910111213job_info = &#123; "jenkins_job_name": "v1_indata_framework", "jenkins_job_number": 1 &#125;post_data = &#123;'data': json.dumps(job_info)&#125;data = urllib.urlencode(post_data)print(data)req2 = urllib2.urlopen(url, data=data)req3 = urllib.urlopen(url, data=data)print (req2.read())print (req3.read())req = urllib2.Request(url, data=data)response = urllib2.urlopen(req) 运行结果：123456data=%7B%22jenkins_job_name%22%3A+%22v1_indata_framework%22%2C+%22jenkins_job_number%22%3A+1%7D&#123;"building": false, "type": true, "result": "SUCCESS"&#125;&#123;"building": false, "type": true, "result": "SUCCESS"&#125;&#123;"building": false, "type": true, "result": "SUCCESS"&#125; 注意：如果读者使用的是 2.x 版本，这里强烈建议在 2.6 和 3.0 版本中使用 urllib2.urlopen()。因为从 2.6 版本开始， urllib 中弃用了 urlopen 函数，而 3.0 版本中移除了该函数。在阅读前面那个核心模块侧边栏时，已经提到这两个模块中的功能在 Python 3 中都合并进了 urllib.request中。这表示 2.x 版本中的 urlib2.urlopen()（已经没有 urllib.urlopen()了）在 3.x 版本中需要使用的 urllib.request.urlopen()函数。 参考资料：urllib和urllib2的区别和使用]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建本地yum源(CentOS)]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0yum%E6%BA%90(CentOS)%2F</url>
    <content type="text"><![CDATA[yum介绍YUM主要用于自动升级、安装\移除rpm软件包，它能自动查找并解决rpm包之间的依赖关系，要成功的使用YUM工具更新系统和软件，需要有一个包含各种rpm软件包的repository（软件仓库），提供软件仓库的服务器习惯上成为“源”服务器。 网络上有大量的源服务器，但是，由于受到网络连接速度、带宽的限制，导致软件安装耗时过长甚至失败。特别是当有大量服务器大量软件包需要升级时，更新的缓慢程序令人难以忍受。 相比较而言，本地YUM源服务器最大优点在局域网的快速网络连接和稳定性。有了局域网中的YUM源服务器，即便在Internet连接中断的情况下，也不会影响其他YUM客户端的软件升级和安装。 搭建本地yum源 安装web服务器(httpd) 1234567yum -y install httpd // 安装httpd服务systemctl enable httpd.servicesystemctl start httpd.service //启动http服务vi /etc/httpd/conf/httpd.conf //修改配置文件Listen 88 //本例修改为88DocumentRoot "/var/www/html" //默认的文件根目录，软件包存放在该目录下 安装createrepo yum-utils工具 1yum -y install yum-utils createrepo 同步网络源至本地 1234567891011# 下载repo文件wget -nv http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.6.2.0/ambari.repo -O /etc/yum.repos.d/ambari.repowget -nv http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.6.5.0/hdp.repo -O /etc/yum.repos.d/hdp.repo# 同步网络源上的rpm包，至/var/www/html目录 cd /var/www/html reposync -r ambari-2.6.2.0reposync -r HDP-2.6.5.0reposync -r HDP-UTILS-1.1.0.22# 或者将下载好的rmp包，拷贝至/var/www/html下对应的子目录下 使用createrepo命令创建repodata 123456cd /var/www/html/ambari-2.6.2.0createrepo ./ # 创建repodatacd /var/www/html/HDP-2.6.5.0createrepo ./cd /var/www/html/HDP-UTILS-1.1.0.22createrepo ./ 使用局域网内的本地yum源 1234567891011121314151617cd /rootmkdri reposvi ambari.repo[Ambari-2.6.2.0]baseurl = http://10.110.13.238:88/ambari/ambari-2.6.2.0 #httpd服务所在的局域网内的主机gpgcheck = 0enalbed = 1name = Ambari-2.6.2.0vi hdp.repovi hdp-utils.repo# 其他的源做相同的操作# 在局域网内的其他主机使用本地源，以10.110.13.33主机为例cd /etc/yum.repo.dmkdir yum.bakmv *.repo yum.bak #备份原有的repo文件，也可删除scp -r 10.110.13.238:/root/repos/* ./ #远程拷贝新建的repo文件至33主机的/etc/yum.repo.d目录 利用系统的iso镜像制作本地源12345cd ~ # iso镜像已拷贝到该目录mkdir isomount -o loop /root/CentOS-7-x86_64-Minimal-1511.iso /root/isocp iso/* /var/www/html/cenos7umout /root/iso #卸载镜像 参考资料：CentOS搭建本地yum源（http方式）]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat vs Apache：您钟情于哪一款]]></title>
    <url>%2F2018%2F07%2F04%2FTomcat%20vs%20Apache%EF%BC%9A%E6%82%A8%E9%92%9F%E6%83%85%E4%BA%8E%E5%93%AA%E4%B8%80%E6%AC%BE%2F</url>
    <content type="text"><![CDATA[ApacheApache Web服务器通常比称之为“Apache”或者“httpd”，Apache是目前最流行的Web应用服务器，拥有超过一亿的网站用户，占据互联网应用服务器63%的份额，以及全球最繁忙网站中有66%采用Apache的（比方说，维基百科网站服务器就是使用Apache）。pache Web服务器是一个用C语言实现的HTTP Web服务器，支持各种特性和模块从而来扩展核心功能。 Apache的优越特性： 访问静态页面比Tomcat要快 Apache有更多的配置选项 支持CGI 脚本，Server API模块，Perl，PHP等Apache的缺点： 不支持Java Servlets或JavaServer Pages(JSP) TomcatApache Tomcat又被称之为“Tomcat”是一款开源的Web服务器，Jakarta项目中的一个核心项目，1999年被开发而成，支持Servlet和JSP，由Apache软件基金会提供支持与维护。Tomcat是靠Java实现的，支持Java Servlets和JavaServer Pages(JSP)，由Oracle公司指定的，因JSPs而著称。Tomcat部分是Apache服务器的扩展，但它是独立运行的，所以当Apache Tomcat运行tomcat时，它实际上是作为一个与Apache独立的进程单独运行的。 Tomcat的优越特性： 提供Java Servlet和JSP支持动态服务器网页 一个轻量级应用服务器 可在不同的模式中运行，以提高其性能 参考资料：Tomcat vs Apache]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用问题记录[文章标题显示no title、设置主页language]]]></title>
    <url>%2F2018%2F06%2F29%2FHexo%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[发布文章，文章标题显示为no title发布流程：将利用其它工具编辑好的(post.md)文件,直接复制到blog/sources/_posts目录下hexo g -d # 生成并部署 原因分析及解决：编辑好的(post.md)文件不符合要求，文档开头添加title字段123---title: this is the title. # 每个markdown文件起始行添加title字段，格式--- 添加title字段后，重新发布，文章标题可正常显示。 博客首页设置为简体中文网上搜索，需要修改 _config.yml配置文件中的language字段[language： zh-Hans] 设置语言总是失败及解决办法：区分开站点配置文件(==blog目录下==)及主题配置文件(==blog/themes/hexo-theme-next目录下==)都是_config.yml且都含有language字段正确的配置方式为：修改站点配置文件的language字段，而非主题配置文件关键点：language字段的值设置为 language： zh-CN (blog/themes/hexo-theme-next/languages/==zh-CN.yml==)该目录下无zh-Hans配置文件 常用命令总结123456# 组合命令hexo g -d # 生成并部署hexo clean # 清除缓存hexo generate # 保存修改，生成文件hexo deploy # 发布到 githubhexo s --debug # 启动本地服务调试 参考资料:Next官网参考资料:个人博客，从入坑开始]]></content>
  </entry>
  <entry>
    <title><![CDATA[Centos-SuSE关闭防火墙]]></title>
    <url>%2F2018%2F06%2F28%2FCentos-SuSE%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[查看防火墙状态12systemctl status firewalld.servie// 查看防火墙状态 关闭防火墙12345systemctl stop firewalld.service// 关闭防火墙// suse系统systemctl stop SuSEfirewall2 禁用防火墙开启启动12345systemctl disable firewalld.service// 禁止firewall开机启动 //suse系统systemctl disable SuSEfirewall2]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElementUi rules表单验证]]></title>
    <url>%2F2018%2F06%2F28%2FElementUi%20rules%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[表单验证之pattern正则表达式123456789virtual_ipaddress: [ &#123;required: true, message: '请输入管理节点虚拟IP', trigger: 'blur'&#125;, &#123;min: 3, max: 16, message: '长度在 3 到 16 个字符', trigger: 'blur'&#125;, # 正则表达式，校验IP地址 &#123; pattern: /^(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])$/, message: '请输入正确格式的IP地址' &#125;] 参考资料：rules表单验证 表单验证之data为多层obj数据1234567891011121314151617181920212223242526272829303132333435// 检验baseConfigForm-&gt;base_config-&gt;ambari_clustername为例baseConfigForm: &#123; base_config: &#123; ambari_clustername: '', keycloak_realm_name: '', keycloak_realm_admin: '', &#125;, config_plan: '', selected_hosts: []&#125;// template中的编写// 深层的数据&lt;el-form :model="baseConfigForm" :rules="rules"&gt; &lt;el-form-item prop="base_config.ambari_clustername"&gt; &lt;el-input :model="baseConfigForm.base_config.ambari_clustername"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt;// 常规的单层数据 &lt;el-form-item prop="config_plan"&gt; &lt;el-input :model="baseConfigForm.config_plan"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt;&lt;/el-form&gt;// rules的编写：rulse:&#123; config_plan: [ &#123;required: true, message: '请选择配置方案', trigger: 'change'&#125; ], 'base_config.keycloak_realm_name': [ &#123;required: true, message: '请输入KeyCloak域名', trigger: 'blur'&#125;, &#123;validator: validateRealm, trigger: 'blur'&#125; ]&#125; 注意事项： 标签中的prop属性必须与item中的model中的数据一一对应,校验才生效！ 参考资料：表单验证model绑定的是一个对象下的某个子对象属性 表单验证之type:array下拉多选，多CheckBox12345678910111213141516171819// template 多选&lt;el-form-item :label="$t('platformList.host')" :label-width="formLabelWidth" prop="selected_hosts"&gt; &lt;el-select v-model="newPlatformInfo.selected_hosts" size="large" multiple :placeholder="$t('platformList.host_placeholder')"&gt; &lt;el-option v-for="item in availableHosts" :key="item" :label="item" :value="item"&gt; &lt;/el-option&gt; &lt;/el-select&gt;&lt;/el-form-item&gt;// rules编写rules:&#123; selected_hosts: [ &#123;required: true, message: '请选择主机', trigger: 'change'&#125;, &#123; type: 'array', max: 3, message: '基础环境最多需要 3 台主机', trigger: 'change' &#125; ], &#125; 效果图： 参考资料：iView Form 表单 表单验证之input输入框数字范围限制123456789101112// el-input Template部分// v-model.number 将输入由字符型转为数值型&lt;el-form-item :label=&quot;$t(&apos;baseConfig.ambari_knox_proxy_port&apos;)&quot; prop=&quot;base_config.ambari_knox_proxy_port&quot;&gt; &lt;el-input v-model.number=&quot;baseConfigForm.base_config.ambari_knox_proxy_port&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt;// rules部分// type:&apos;number&apos;,min,max限制输入数值的范围&apos;base_config.ambari_nifi_proxy_port&apos;: [ &#123;required: true, message: this.$t(&apos;baseConfig.msg_nifi_proxy_port&apos;), trigger: &apos;blur&apos;&#125;, &#123;type: &apos;number&apos;, min: 1, max:65535, message: this.$t(&apos;baseConfig.msg_port_range&apos;), trigger: &apos;blur&apos;&#125;, &#123;validator: validateNiFiProxyPort, trigger: &apos;blur&apos;&#125;], 效果图：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
