<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shell编程--判断条件]]></title>
    <url>%2F2018%2F08%2F13%2Fshell%E7%BC%96%E7%A8%8B--%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. 关于某个档名的『文件类型』判断，如 test -e filename 表示存在否 测试的标志 代表意义 -e 该『档名』是否存在？(常用) -f 该『档名』是否存在且为文件(file)？(常用) -d 该『档名』是否存在且为目录(directory)？(常用) -b 该『档名』是否存在且为一个 block device 装置？ -c 该『档名』是否存在且为一个 character device 装置？ -S 该『档名』是否存在且为一个 Socket 文件？ -p 该『档名』是否存在且为一个 FIFO (pipe) 文件？ -L 该『档名』是否存在且为一个连结档？ 2. 关于文件的权限测试，如 test -r filename 表示可读否 (但 root 权限常有例外) 测试的标志 代表的意义 -r 侦测该档名是否存在且具有『可读』的权限？ -w 侦测该档名是否存在且具有『可写』的权限？ -x 侦测该档名是否存在且具有『可运行』的权限？ -u 侦测该档名是否存在且具有『SUID』的属性？ -g 侦测该档名是否存在且具有『SGID』的属性？ -k 侦测该档名是否存在且具有『Sticky bit』的属性？ -s 侦测该档名是否存在且为『非空白文件』？ 示例：123456789101112# stat -c %A test_do.sh -rw-r--r--# test -x test_do.sh &amp;&amp; echo "Executable" || echo "Not Executable"Not Executable# chmod +x test_do.sh# stat -c %A test_do.sh -rwxr-xr-x# test -x test_do.sh &amp;&amp; echo "Executable" || echo "Not Executable"Executable# stat -c %a test_do.sh 755 说明：对于&amp;&amp;：当前面执行条件正确时，执行&amp;&amp;之后的，错误就停住了。对于||：当前面的执行条件错误时，执行||之后的，正确就停住了。因此根据&amp;&amp;、||的特性可以对条件作出一个模式“条件 &amp;&amp; 执行1|| 执行2”。当条件为真时执行1；当为假时“条件&amp;&amp;执行1”绝对为假，因此执行2。 stat 这个命令可以实现数字形式输出文件的权限 参数 参数含义 - c –format=FORMAT %a access rights in octal （8进制数显示文件权限） %A access rights in human readable form（可阅读方式显示文件权限） 3. 关于两个整数之间的判定，例如 test n1 -eq n2 测试的标志 代表的意义 -eq 两数值相等 (equal) -ne 两数值不等 (not equal) -gt n1 大于 n2 (greater than) -lt n1 小于 n2 (less than) -ge n1 大于等于 n2 (greater than or equal) -le n1 小于等于 n2 (less than or equal) 鸟哥Linux私房菜： 第十三章、3.1 testshell编程——判断条件]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nmap使用记录]]></title>
    <url>%2F2018%2F08%2F09%2Fnmap%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Nmap（Network Mapper）是一款开放源代码的网络探测和安全审核工具。它用于快速扫描一个网络和一台主机开放的端口，还能使用TCP/IP协议栈特征探测远程主机的操作系统类型 安装1yum -y install nmap # centos redhat 主机发现123nmap -T4 -sP 10.110.13.0/24nmap -T4 -sP 10.110.13.*nmap -T4 -sn 10.110.13.0/24 以上三条命令的运行效果一样，得到相同的结果，即扫描13网段的256个ip主机的活跃状态参数说明：12345nmap --help -sn: Ping Scan - disable port scan #ping 扫描，禁用端口扫描-T&lt;0-5&gt;: Set timing template (higher is faster) # -T4 代表快速扫描* # 是通配符0/24 # 代表子网掩码(255.255.255.0) 关于子网掩码的问题请戳我 而之前一直使用-sP参数，nmap –help 与man nmap都未发现-sP参数。网上搜索一番： -sT TCP connect()扫描，这是最基本的TCP扫描方式。这种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息。 -sS TCP同步扫描(TCP SYN)，因为不必全部打开一个TCP连接，所以这项技术通常称为半开扫描(half-open)。这项技术最大的好处是，很少有系统能够把这记入系统日志。不过，你需要root权限来定制SYN数据包。 -sF,-sX,-sN 秘密FIN数据包扫描、圣诞树(Xmas Tree)、空(Null)扫描模式。这些扫描方式的理论依据是：关闭的端口需要对你的探测包回应RST包，而打开的端口必需忽略有问题的包(参考RFC 793第64页)。 -sP ping扫描，用ping方式检查网络上哪些主机正在运行。当主机阻塞ICMP echo请求包是ping扫描是无效的。nmap在任何情况下都会进行ping扫描，只有目标主机处于运行状态，才会进行后续的扫描。 -sU 如果你想知道在某台主机上提供哪些UDP(用户数据报协议,RFC768)服务，可以使用此选项。 -sA ACK扫描，这项高级的扫描方法通常可以用来穿过防火墙。 -sW 滑动窗口扫描，非常类似于ACK的扫描。 -sR RPC扫描，和其它不同的端口扫描方法结合使用。 -b FTP反弹攻击(bounce attack)，连接到防火墙后面的一台FTP服务器做代理，接着进行端口扫描。 nmap 使用参考继续查看官网发现一句英文的解释：In previous releases of Nmap, -sn was known as -sP.即旧版中为-sP官网英文doc参考 常见的使用方式12nmap 192.168.0.101-110 # ip范围nmap 192.168.0.101,102,103 # 逗号扫描多个主机 更多使用:详见]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-resource几种使用场景记录]]></title>
    <url>%2F2018%2F08%2F08%2Fvue-resource%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[post提交的数据格式为(form-data/x-www-form-urlencoded) post(url, [body], [options])options = {emulateJSON: true}以 application/x-www-form-urlencoded 内容类型发送请求报文 1234567891011121314let formData = &#123; username: 'admin', password: 'admin'&#125;;this.$http.post('/login', formData, &#123;emulateJSON: true&#125;).then( (response) =&gt; &#123; // 请求成功 &#125;, (response) =&gt; &#123; // 请求失败 &#125;) post设置请求头(headers) post(url, [body], [options])body为空占位，headers属于第三个参数[options]12345678910let token = 'Basic YWRtaW46YWRtaW4='this.$http.post('/auth',&#123;&#125;,&#123;headers: &#123;Authorization: token&#125;&#125;).then( (response) =&gt; &#123; // 请求成功 &#125;, (response) =&gt; &#123; // 请求失败 &#125;) 参考资料：How to set headers? post提交json数据(最常规)12345678910111213let post_data = &#123; group:'test', name:'foundation'&#125;this.$http.post('/platform_hostsgroup'), post_data).then( (response) =&gt; &#123; // 请求成功 &#125;, (response) =&gt; &#123; // 请求失败 &#125;) delete方法提交json数据使用方式：this.$http.delete(url, {body: data})12345678910let host_ip = '172.16.10.100'this.$http.delete('/host', &#123;body: &#123;ip: host_ip&#125;&#125;).then( (response) =&gt; &#123; // 请求成功 &#125;, (response) =&gt; &#123; // 请求失败 &#125;) 参考资料：vue http请求 delete传值问题]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter的安装及使用]]></title>
    <url>%2F2018%2F07%2F14%2Fjupyter%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装1pip install jupyter 生成配置文件1jupyter notebook --generate-config 设置登录密码123jupyter notebook password# 输出结果Wrote hashed password to /root/.jupyter/jupyter_notebook_config.json 后台启动服务1234nohup jupyter notebook --no-browser --allow-root --ip=0.0.0.0 &amp;# nohup command &amp; 设置后台运行# --no-browser 启动不打开浏览器# --ip 指定ip地址，可以为任意ip 使用浏览器地址栏输入server_ip:8888 访问，出现登录界面，输入设置的密码，即可使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[urllib、urllib2的使用及区别]]></title>
    <url>%2F2018%2F07%2F13%2Furllib%E3%80%81urllib2%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[urllib.urlopen()的使用12# urllib模块的urlopen()方法原型def urlopen(url, data=None, proxies=None, context=None): urlopen()打开一个给定 URL 字符串表示的 Web 连接，并返回文件类型的对象。例如,返回的对象是res，那么“句柄”会支持一些读取内容的方法，如 res.read()、res.readline()、 res.readlines()、 res.close()和 res.fileno()。其中data需要使用urllib.urlencode(dict)进行编码处理，帮我们将key:value这样的键值对转换成”key=value”这样的字符串。 123456// 实例：student = &#123;'name':'LiLei','age':18,'school': 'TsingHua'&#125;encode_student = urllib.urlencode(student)print(encode_student)age=18&amp;name=LiLei&amp;school=TsingHua // url编码后 更复杂的应用场景，使用urllib2.urlopen()12345678910# urllib2模块的urlopen()方法原型def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, cafile=None, capath=None, cadefault=False, context=None): # urllib2.Request类原型class Request: def __init__(self, url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False): 通过Request类实例化request对象，并设置请求头，认证等复杂应用123456# 实例，设置请求头等，add_header()方法def post_request(url, data): req = urllib2.Request(url + '?' + urllib.urlencode(data)) req.add_header('User-Agent','Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36') response = urllib2.urlopen(req) return response.read() 简单应用场景，三者等价12345678910111213job_info = &#123; "jenkins_job_name": "v1_indata_framework", "jenkins_job_number": 1 &#125;post_data = &#123;'data': json.dumps(job_info)&#125;data = urllib.urlencode(post_data)print(data)req2 = urllib2.urlopen(url, data=data)req3 = urllib.urlopen(url, data=data)print (req2.read())print (req3.read())req = urllib2.Request(url, data=data)response = urllib2.urlopen(req) 运行结果：123456data=%7B%22jenkins_job_name%22%3A+%22v1_indata_framework%22%2C+%22jenkins_job_number%22%3A+1%7D&#123;"building": false, "type": true, "result": "SUCCESS"&#125;&#123;"building": false, "type": true, "result": "SUCCESS"&#125;&#123;"building": false, "type": true, "result": "SUCCESS"&#125; 注意：如果读者使用的是 2.x 版本，这里强烈建议在 2.6 和 3.0 版本中使用 urllib2.urlopen()。因为从 2.6 版本开始， urllib 中弃用了 urlopen 函数，而 3.0 版本中移除了该函数。在阅读前面那个核心模块侧边栏时，已经提到这两个模块中的功能在 Python 3 中都合并进了 urllib.request中。这表示 2.x 版本中的 urlib2.urlopen()（已经没有 urllib.urlopen()了）在 3.x 版本中需要使用的 urllib.request.urlopen()函数。 参考资料：urllib和urllib2的区别和使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建本地yum源(CentOS)]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0yum%E6%BA%90(CentOS)%2F</url>
    <content type="text"><![CDATA[yum介绍YUM主要用于自动升级、安装\移除rpm软件包，它能自动查找并解决rpm包之间的依赖关系，要成功的使用YUM工具更新系统和软件，需要有一个包含各种rpm软件包的repository（软件仓库），提供软件仓库的服务器习惯上成为“源”服务器。 网络上有大量的源服务器，但是，由于受到网络连接速度、带宽的限制，导致软件安装耗时过长甚至失败。特别是当有大量服务器大量软件包需要升级时，更新的缓慢程序令人难以忍受。 相比较而言，本地YUM源服务器最大优点在局域网的快速网络连接和稳定性。有了局域网中的YUM源服务器，即便在Internet连接中断的情况下，也不会影响其他YUM客户端的软件升级和安装。 搭建本地yum源 安装web服务器(httpd) 1234567yum -y install httpd // 安装httpd服务systemctl enable httpd.servicesystemctl start httpd.service //启动http服务vi /etc/httpd/conf/httpd.conf //修改配置文件Listen 88 //本例修改为88DocumentRoot "/var/www/html" //默认的文件根目录，软件包存放在该目录下 安装createrepo yum-utils工具 1yum -y install yum-utils createrepo 同步网络源至本地 1234567891011# 下载repo文件wget -nv http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.6.2.0/ambari.repo -O /etc/yum.repos.d/ambari.repowget -nv http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.6.5.0/hdp.repo -O /etc/yum.repos.d/hdp.repo# 同步网络源上的rpm包，至/var/www/html目录 cd /var/www/html reposync -r ambari-2.6.2.0reposync -r HDP-2.6.5.0reposync -r HDP-UTILS-1.1.0.22# 或者将下载好的rmp包，拷贝至/var/www/html下对应的子目录下 使用createrepo命令创建repodata 123456cd /var/www/html/ambari-2.6.2.0createrepo ./ # 创建repodatacd /var/www/html/HDP-2.6.5.0createrepo ./cd /var/www/html/HDP-UTILS-1.1.0.22createrepo ./ 使用局域网内的本地yum源 1234567891011121314151617cd /rootmkdri reposvi ambari.repo[Ambari-2.6.2.0]baseurl = http://10.110.13.238:88/ambari/ambari-2.6.2.0 #httpd服务所在的局域网内的主机gpgcheck = 0enalbed = 1name = Ambari-2.6.2.0vi hdp.repovi hdp-utils.repo# 其他的源做相同的操作# 在局域网内的其他主机使用本地源，以10.110.13.33主机为例cd /etc/yum.repo.dmkdir yum.bakmv *.repo yum.bak #备份原有的repo文件，也可删除scp -r 10.110.13.238:/root/repos/* ./ #远程拷贝新建的repo文件至33主机的/etc/yum.repo.d目录 利用系统的iso镜像制作本地源12345cd ~ # iso镜像已拷贝到该目录mkdir isomount -o loop /root/CentOS-7-x86_64-Minimal-1511.iso /root/isocp iso/* /var/www/html/cenos7umout /root/iso #卸载镜像 参考资料：CentOS搭建本地yum源（http方式）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tomcat vs Apache：您钟情于哪一款]]></title>
    <url>%2F2018%2F07%2F04%2FTomcat%20vs%20Apache%EF%BC%9A%E6%82%A8%E9%92%9F%E6%83%85%E4%BA%8E%E5%93%AA%E4%B8%80%E6%AC%BE%2F</url>
    <content type="text"><![CDATA[ApacheApache Web服务器通常比称之为“Apache”或者“httpd”，Apache是目前最流行的Web应用服务器，拥有超过一亿的网站用户，占据互联网应用服务器63%的份额，以及全球最繁忙网站中有66%采用Apache的（比方说，维基百科网站服务器就是使用Apache）。pache Web服务器是一个用C语言实现的HTTP Web服务器，支持各种特性和模块从而来扩展核心功能。 Apache的优越特性： 访问静态页面比Tomcat要快 Apache有更多的配置选项 支持CGI 脚本，Server API模块，Perl，PHP等Apache的缺点： 不支持Java Servlets或JavaServer Pages(JSP) TomcatApache Tomcat又被称之为“Tomcat”是一款开源的Web服务器，Jakarta项目中的一个核心项目，1999年被开发而成，支持Servlet和JSP，由Apache软件基金会提供支持与维护。Tomcat是靠Java实现的，支持Java Servlets和JavaServer Pages(JSP)，由Oracle公司指定的，因JSPs而著称。Tomcat部分是Apache服务器的扩展，但它是独立运行的，所以当Apache Tomcat运行tomcat时，它实际上是作为一个与Apache独立的进程单独运行的。 Tomcat的优越特性： 提供Java Servlet和JSP支持动态服务器网页 一个轻量级应用服务器 可在不同的模式中运行，以提高其性能 参考资料：Tomcat vs Apache]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用问题记录[文章标题显示no title、设置主页language]]]></title>
    <url>%2F2018%2F06%2F29%2FHexo%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[发布文章，文章标题显示为no title发布流程：将利用其它工具编辑好的(post.md)文件,直接复制到blog/sources/_posts目录下hexo g -d # 生成并部署 原因分析及解决：编辑好的(post.md)文件不符合要求，文档开头添加title字段123---title: this is the title. # 每个markdown文件起始行添加title字段，格式--- 添加title字段后，重新发布，文章标题可正常显示。 博客首页设置为简体中文网上搜索，需要修改 _config.yml配置文件中的language字段[language： zh-Hans] 设置语言总是失败及解决办法：区分开站点配置文件(==blog目录下==)及主题配置文件(==blog/themes/hexo-theme-next目录下==)都是_config.yml且都含有language字段正确的配置方式为：修改站点配置文件的language字段，而非主题配置文件关键点：language字段的值设置为 language： zh-CN (blog/themes/hexo-theme-next/languages/==zh-CN.yml==)该目录下无zh-Hans配置文件 常用命令总结123456# 组合命令hexo g -d # 生成并部署hexo clean # 清除缓存hexo generate # 保存修改，生成文件hexo deploy # 发布到 githubhexo s --debug # 启动本地服务调试 参考资料:Next官网参考资料:个人博客，从入坑开始]]></content>
  </entry>
  <entry>
    <title><![CDATA[Centos-SuSE关闭防火墙]]></title>
    <url>%2F2018%2F06%2F28%2FCentos-SuSE%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[查看防火墙状态12systemctl status firewalld.servie// 查看防火墙状态 关闭防火墙12345systemctl stop firewalld.service// 关闭防火墙// suse系统systemctl stop SuSEfirewall2 禁用防火墙开启启动12345systemctl disable firewalld.service// 禁止firewall开机启动 //suse系统systemctl disable SuSEfirewall2]]></content>
  </entry>
  <entry>
    <title><![CDATA[ElementUi rules表单验证(pattern正则表达式)]]></title>
    <url>%2F2018%2F06%2F28%2FElementUi%20rules%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81(pattern%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)%2F</url>
    <content type="text"><![CDATA[表单验证123456789virtual_ipaddress: [ &#123;required: true, message: '请输入管理节点虚拟IP', trigger: 'blur'&#125;, &#123;min: 3, max: 16, message: '长度在 3 到 16 个字符', trigger: 'blur'&#125;, # 正则表达式，校验IP地址 &#123; pattern: /^(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])$/, message: '请输入正确格式的IP地址' &#125;] 参考资料：rules表单验证 表单验证之data为多层obj数据1234567891011121314151617181920212223242526272829303132333435// 检验baseConfigForm-&gt;base_config-&gt;ambari_clustername为例baseConfigForm: &#123; base_config: &#123; ambari_clustername: '', keycloak_realm_name: '', keycloak_realm_admin: '', &#125;, config_plan: '', selected_hosts: []&#125;// template中的编写// 深层的数据&lt;el-form :model="baseConfigForm" :rules="rules"&gt; &lt;el-form-item prop="base_config.ambari_clustername"&gt; &lt;el-input :model="baseConfigForm.base_config.ambari_clustername"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt;// 常规的单层数据 &lt;el-form-item prop="config_plan"&gt; &lt;el-input :model="baseConfigForm.config_plan"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt;&lt;/el-form&gt;// rules的编写：rulse:&#123; config_plan: [ &#123;required: true, message: '请选择配置方案', trigger: 'change'&#125; ], 'base_config.keycloak_realm_name': [ &#123;required: true, message: '请输入KeyCloak域名', trigger: 'blur'&#125;, &#123;validator: validateRealm, trigger: 'blur'&#125; ]&#125; 注意事项： 标签中的prop属性必须与item中的model中的数据一一对应,校验才生效！ 参考资料：表单验证model绑定的是一个对象下的某个子对象属性]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
